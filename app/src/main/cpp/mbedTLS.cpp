#include <jni.h>

#include <string>
#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>
#include <android/log.h>
#include "mbedtls/entropy.h"
#include "mbedtls/ctr_drbg.h"
#include "mbedtls/bignum.h"
#include "mbedtls/x509.h"
#include "mbedtls/rsa.h"
#include "mbedtls/md5.h"
#include "mbedtls/dhm.h"
#include "mbedtls/cipher.h"
#include <mbedtls/gcm.h>
#include "mbedtls/ecdh.h"
#include "mbedtls/pk.h"


#include <time.h>
#include <cstring>

#define HEAP_HINT NULL



#define BITS_TO_BYTES(b)                (b/8)
#define MIN_OAEP_PADDING                (2*BITS_TO_BYTES(160)+2)

#define RSA_LENGTH                      (BITS_TO_BYTES(2048))

#define RSA_OAEP_DECRYPTED_DATA_LENGTH  (RSA_LENGTH-MIN_OAEP_PADDING)
#define RSA_OAEP_ENCRYPTED_DATA_LENGTH  (RSA_LENGTH)


#define  LOGD(...)  __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG ,__VA_ARGS__)

#define  LOG_TAG    "mbedTLS"

#define KEY_SIZE 2048
#define EXPONENT 65537

#define DFL_BITS    2048
#define GENERATOR "4"


/*extern "C"
JNIEXPORT jintArray JNICALL
Java_com_example_juanperezdealgaba_sac_mbedTLS_RSA(JNIEnv *env, jobject instance) {

    jintArray resultArray;
    resultArray = env->NewIntArray(3);
    jint fill[3];
    struct timeval st,et;

    int ret;
    int return_val;
    mbedtls_rsa_context rsa;
    mbedtls_entropy_context entropy;
    mbedtls_ctr_drbg_context ctr_drbg;
    const char *pers = "rsa_genkey";
    size_t i;

    char *argv[2];

    argv[1] = const_cast<char *>("Inputtt");

    unsigned char input[1024];
    unsigned char buf[512];
    unsigned char result[1024];

    mbedtls_ctr_drbg_init( &ctr_drbg );

    LOGD("Seeding the random number generator");
    fflush( stdout );

    mbedtls_entropy_init( &entropy );
    if( ( ret = mbedtls_ctr_drbg_seed( &ctr_drbg, mbedtls_entropy_func, &entropy,
                                       (const unsigned char *) pers,
                                       strlen( pers ) ) ) != 0 )
    {
        LOGD( " failed\n  ! mbedtls_ctr_drbg_seed returned %d\n", ret );
        return 0;
    }

    LOGD( " ok\n  . Generating the RSA key [ %d-bit ]...", KEY_SIZE );
    fflush( stdout );

    mbedtls_rsa_init( &rsa, MBEDTLS_RSA_PKCS_V15, 0 );

    if( ( ret = mbedtls_rsa_gen_key( &rsa, mbedtls_ctr_drbg_random, &ctr_drbg, KEY_SIZE,
                                     EXPONENT ) ) != 0 )
    {
        LOGD( " failed\n  ! mbedtls_rsa_gen_key returned %d\n\n", ret );
        return 0;
    }

    memcpy( input, argv[1], strlen( argv[1] ) );

    LOGD( "\n  . Generating the RSA encrypted value" );

    gettimeofday(&st,NULL);

    return_val = mbedtls_rsa_pkcs1_encrypt( &rsa, mbedtls_ctr_drbg_random,
                                            &ctr_drbg, MBEDTLS_RSA_PUBLIC,
                                            strlen( argv[1] ), input, buf );

    gettimeofday(&et,NULL);

    int encryption_time = ((et.tv_sec - st.tv_sec) * 1000000) + (et.tv_usec - st.tv_usec);

    fill[0] = encryption_time;

    if( return_val != 0 )
    {

        LOGD( " failed\n  ! mbedtls_rsa_pkcs1_encrypt returned %d\n\n",
              return_val );
        return 0;
    }



    LOGD("Finished encryption");

    LOGD( "\n  . Decrypting the encrypted data" );

    gettimeofday(&st,NULL);

    return_val = mbedtls_rsa_pkcs1_decrypt( &rsa, mbedtls_ctr_drbg_random,
                                            &ctr_drbg, MBEDTLS_RSA_PRIVATE, &i,
                                            buf, result, 1024 );
    gettimeofday(&et,NULL);

    int decryption_time = ((et.tv_sec - st.tv_sec) * 1000000) + (et.tv_usec - st.tv_usec);

    fill[1] = decryption_time;

    if( return_val != 0 )
    {
        LOGD( " failed\n  ! mbedtls_rsa_pkcs1_decrypt returned %d\n\n",
              return_val );
        return 0;
    }

    LOGD( "\n  . OK\n\n" );

    LOGD( "The decrypted result is: '%s'\n\n", result );

    mbedtls_rsa_free( &rsa );
    mbedtls_ctr_drbg_free( &ctr_drbg );
    mbedtls_entropy_free( &entropy );


    env->SetIntArrayRegion(resultArray, 0, 3, fill);
    return resultArray;

}*/

extern "C"
JNIEXPORT jintArray JNICALL
Java_com_example_juanperezdealgaba_sac_mbedTLS_AESCBC(JNIEnv *env, jobject instance) {

    jintArray result;
    result = env->NewIntArray(3);
    jint fill[3];

    const uint8_t Plaintext[64] =
            {
                    0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96,
                    0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,
                    0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c,
                    0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,
                    0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11,
                    0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef,
                    0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17,
                    0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10
            };


    uint8_t key[16] = {
            0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7,
            0x15, 0x88,
            0x09, 0xcf, 0x4f, 0x3c
    };

    uint8_t iv[16] = {
            0x09, 0xcf,0x15, 0x88, 0x4f, 0x3c,0x2b, 0x7e, 0x15,0xae,0x16, 0x28, 0xd2, 0xa6, 0xab, 0xf7,

    };


    struct timeval st,et;
    uint8_t OutputMessage[64];
    uint8_t compare[64];
    uint32_t i=0,status = 0;

    mbedtls_aes_context ctx;
    mbedtls_aes_init( &ctx );
    status = mbedtls_aes_setkey_enc( &ctx, key, 128 );
    if(status != 0)
    {
        LOGD("\n mbedtls Encrypt set key failed");
    }

    gettimeofday(&st,NULL);
    status = mbedtls_aes_crypt_cbc( &ctx, MBEDTLS_AES_ENCRYPT, 64, iv, Plaintext, OutputMessage );
    gettimeofday(&et,NULL);
    int encryption_time = ((et.tv_sec - st.tv_sec) * 1000000) + (et.tv_usec - st.tv_usec);

    fill[0] = encryption_time;
    if(status != 0)
    {
        LOGD("\n mbedtls encryption failed");
    }


    uint8_t iv2[16] = {
            0x09, 0xcf,0x15, 0x88, 0x4f, 0x3c,0x2b, 0x7e, 0x15,0xae,0x16, 0x28, 0xd2, 0xa6, 0xab, 0xf7,

    };

    mbedtls_aes_init( &ctx );
    status = mbedtls_aes_setkey_dec(&ctx, key, 128);
    if(status != 0)
    {
        LOGD("\n mbedtls decryption set key failed");
    }

    gettimeofday(&st,NULL);
    status = mbedtls_aes_crypt_cbc( &ctx, MBEDTLS_AES_DECRYPT, 64, iv2, OutputMessage,compare);
    gettimeofday(&et,NULL);
    int decryption_time = ((et.tv_sec - st.tv_sec) * 1000000) + (et.tv_usec - st.tv_usec);

    fill[1] = decryption_time;
    if(status != 0)
    {
        LOGD("\n mbedtls encryption failed");
    }

    LOGD("AES finished");
    LOGD("Plain decrypted:");
    for (int i = 0; i < 64; ++i) {
        LOGD("%x", compare[i]);
    }
    mbedtls_aes_free( &ctx );

    env->SetIntArrayRegion(result, 0, 3, fill);
    return result;
}

extern "C"
JNIEXPORT jintArray JNICALL
Java_com_example_juanperezdealgaba_sac_mbedTLS_MD5(JNIEnv *env, jobject instance) {

    jintArray result;
    result = env->NewIntArray(3);
    jint fill[3];
    struct timeval st,et;

    jintArray error[1];

    int i, ret;
    unsigned char digest[16];
    char str[] = "Hello, world!";

    LOGD( "\n  MD5('%s') = ", str );

    gettimeofday(&st,NULL);
    if(  (ret = mbedtls_md5_ret( (unsigned char *) str, 13, digest ))  != 0 ) {
        return 0;
    }
    gettimeofday(&et,NULL);

    int generation_time = ((et.tv_sec - st.tv_sec) * 1000000) + (et.tv_usec - st.tv_usec);

    fill[1] = generation_time;


    for( i = 0; i < 16; i++ )
        LOGD( "%02x", digest[i] );

    LOGD( "Finished!" );

    env->SetIntArrayRegion(result, 0, 3, fill);

    return result;

}

extern "C"
JNIEXPORT jintArray JNICALL
Java_com_example_juanperezdealgaba_sac_mbedTLS_DH(JNIEnv *env, jobject instance) {

    jintArray result;
    result = env->NewIntArray(3);
    jint fill[3];

    struct timeval st,et;

    int ret;
    size_t n1, buflen;
    size_t n2;
    unsigned char buf1[2048];
    unsigned char buf2[2048];
    mbedtls_dhm_context dhm1;
    mbedtls_ctr_drbg_context ctr_drbg1;
    mbedtls_entropy_context entropy1;

    mbedtls_dhm_context dhm2;
    mbedtls_ctr_drbg_context ctr_drbg2;
    mbedtls_entropy_context entropy2;

    const char *pers = "dh_test";

    mbedtls_dhm_init( &dhm1 );
    mbedtls_ctr_drbg_init( &ctr_drbg1 );

    mbedtls_dhm_init( &dhm2 );
    mbedtls_ctr_drbg_init( &ctr_drbg2 );

    mbedtls_entropy_init( &entropy1 );
    mbedtls_entropy_init( &entropy2 );

    if( ( ret = mbedtls_ctr_drbg_seed( &ctr_drbg1, mbedtls_entropy_func, &entropy1,
                                       (const unsigned char *) pers,
                                       strlen( pers ) ) ) != 0 )
    {
        LOGD( " failed 1\n  ! mbedtls_ctr_drbg_seed returned %d\n", ret );
    }

    ret= mbedtls_mpi_read_string(&dhm1.P,16,MBEDTLS_DHM_RFC5114_MODP_2048_P);
    if(ret != 0){
        LOGD("Error at reading P 1");
    }

    ret = mbedtls_mpi_read_string(&dhm1.G,16,MBEDTLS_DHM_RFC5114_MODP_2048_G);
    if(ret != 0){
        LOGD("Error at reading G 1");
    }

    ret = mbedtls_dhm_make_params( &dhm1, (int) mbedtls_mpi_size( &dhm1.P ), buf1, &n1,
                                         mbedtls_ctr_drbg_random, &ctr_drbg1 );

    if(ret != 0){
        LOGD("Error at make params 1");
    }

    if( ( ret = mbedtls_ctr_drbg_seed( &ctr_drbg2, mbedtls_entropy_func, &entropy2,
                                       (const unsigned char *) pers,
                                       strlen( pers ) ) ) != 0 )
    {
        LOGD( " failed 1\n  ! mbedtls_ctr_drbg_seed returned %d\n", ret );
    }

    ret= mbedtls_mpi_read_string(&dhm2.P,16,MBEDTLS_DHM_RFC5114_MODP_2048_P);
    if(ret != 0){
        LOGD("Error at reading P 2");
    }

    ret = mbedtls_mpi_read_string(&dhm2.G,16,MBEDTLS_DHM_RFC5114_MODP_2048_G);
    if(ret != 0){
        LOGD("Error at reading G 2");
    }

    mbedtls_dhm_make_params( &dhm2, (int) mbedtls_mpi_size( &dhm2.P ), buf2, &n2,
                             mbedtls_ctr_drbg_random, &ctr_drbg2 );

    n2 = dhm2.len;
    if( ( ret = mbedtls_dhm_make_public( &dhm2, (int) dhm2.len, buf2, n2,
                                         mbedtls_ctr_drbg_random, &ctr_drbg2 ) ) != 0 )
    {
        LOGD( " failed\n  ! mbedtls_dhm_make_public returned %d\n\n", ret );
    }

    n1 = dhm2.len;
    if( ( ret = mbedtls_dhm_make_public( &dhm1, (int) dhm1.len, buf1, n1,
                                         mbedtls_ctr_drbg_random, &ctr_drbg1 ) ) != 0 )
    {
        LOGD( " failed\n  ! mbedtls_dhm_make_public returned %d\n\n", ret );
    }

    if( ( ret = mbedtls_dhm_read_public( &dhm2, buf1, dhm1.len ) ) != 0 )
    {
        LOGD( " failed\n  ! mbedtls_dhm_read_public returned %d\n\n", ret );
    }

    if( ( ret = mbedtls_dhm_read_public( &dhm1, buf2, dhm2.len ) ) != 0 )
    {
        LOGD( " failed\n  ! mbedtls_dhm_read_public returned %d\n\n", ret );
    }

    gettimeofday(&st,NULL);
    if( ( ret = mbedtls_dhm_calc_secret( &dhm1, buf1, sizeof( buf1 ), &n1,
                                         mbedtls_ctr_drbg_random, &ctr_drbg1 ) ) != 0 )
    {
        LOGD( " failed\n  ! mbedtls_dhm_calc_secret returned %d\n\n", ret );
    }

    if( ( ret = mbedtls_dhm_calc_secret( &dhm2, buf2, sizeof( buf2 ), &n2,
                                         mbedtls_ctr_drbg_random, &ctr_drbg2 ) ) != 0 )
    {
        LOGD( " failed\n  ! mbedtls_dhm_calc_secret returned %d\n\n", ret );
    }

    gettimeofday(&et,NULL);
    int generation_time = ((et.tv_sec - st.tv_sec) * 1000000) + (et.tv_usec - st.tv_usec);
    fill[1] = generation_time;

    LOGD("BUF1");
    for( int i = 0; i < 16; i++ )
        LOGD( "%02x", buf1[i] );
    LOGD("BUF2");
    for( int i = 0; i < 16; i++ )
        LOGD( "%02x", buf2[i] );

    LOGD("DH finished");

    env->SetIntArrayRegion(result, 0, 3, fill);

    return result;

}

extern "C"
JNIEXPORT jintArray JNICALL
Java_com_example_juanperezdealgaba_sac_mbedTLS_AESCTR(JNIEnv *env, jobject instance) {

    jintArray result;
    result = env->NewIntArray(3);
    jint fill[3];

    struct timeval st, et;

    unsigned char key[16] = {
            0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7,
            0x15, 0x88,
            0x09, 0xcf, 0x4f, 0x3c
    };

    unsigned char iv[16] = {
            0x09, 0xcf,0x15, 0x88, 0x4f, 0x3c,0x2b, 0x7e, 0x15,0xae,0x16, 0x28, 0xd2, 0xa6, 0xab, 0xf7,

    };

    const unsigned char plaintext[64] = {
            0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,
            0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c, 0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,
            0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11, 0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef,
            0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17, 0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10
    };


    size_t nc_off = 0;
    unsigned char stream_block[16] = {0};
    uint8_t enc_out[64];
    memset(enc_out, 0, sizeof(enc_out));

    uint8_t plain_out[64];
    memset(plain_out, 0, sizeof(plain_out));

    mbedtls_aes_context aes;
    mbedtls_aes_init(&aes);
    mbedtls_aes_setkey_enc( &aes, key, 128);

    int ret;

    gettimeofday(&st,NULL);
    ret = mbedtls_aes_crypt_ctr(&aes, sizeof(plaintext), &nc_off, iv, stream_block, plaintext, enc_out);
    gettimeofday(&et,NULL);
    int encryption_time = ((et.tv_sec - st.tv_sec) * 1000000) + (et.tv_usec - st.tv_usec);

    if (ret == 0){
        LOGD("Success encrypting");
    }

    fill[0] = encryption_time;

    gettimeofday(&st,NULL);
    ret = mbedtls_aes_crypt_ctr(&aes, sizeof(enc_out), &nc_off, iv, stream_block, enc_out, plain_out);
    gettimeofday(&et,NULL);
    int decryption_time = ((et.tv_sec - st.tv_sec) * 1000000) + (et.tv_usec - st.tv_usec);

    if (ret == 0){
        LOGD("Success decrypting");
    }

    fill[1] = decryption_time;


    mbedtls_aes_free(&aes);

    env->SetIntArrayRegion(result, 0, 3, fill);

    return result;
}

extern "C"
JNIEXPORT jintArray JNICALL
Java_com_example_juanperezdealgaba_sac_mbedTLS_AESGCM(JNIEnv *env, jobject instance) {

    jintArray result;
    result = env->NewIntArray(3);
    jint fill[3];

    struct timeval st,et;

    unsigned char key[16] = {
            0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7,
            0x15, 0x88,
            0x09, 0xcf, 0x4f, 0x3c
    };

    unsigned char iv[16] = {
            0x09, 0xcf,0x15, 0x88, 0x4f, 0x3c,0x2b, 0x7e, 0x15,0xae,0x16, 0x28, 0xd2, 0xa6, 0xab, 0xf7,

    };

    const unsigned char plaintext[64] = {
            0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,
            0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c, 0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,
            0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11, 0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef,
            0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17, 0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10
    };

    unsigned char encrypted[64];
    unsigned char decrypted[64];

    unsigned char tag[16];

    mbedtls_gcm_context ctx;

    mbedtls_gcm_init(&ctx);

    int ret = mbedtls_gcm_setkey(&ctx,MBEDTLS_CIPHER_ID_AES,key, 128);
    if(ret != 0){
        LOGD("%i",ret);
    }

    gettimeofday(&st,NULL);

    //I use the "high-level" interface as explained in this post : https://tls.mbed.org/discussions/generic/aes-gcm-authenticated-encryption-example

   ret = mbedtls_gcm_crypt_and_tag(&ctx,MBEDTLS_GCM_ENCRYPT, sizeof(plaintext),iv, sizeof(iv),NULL,0,plaintext,encrypted,
                              sizeof(tag),tag);
    gettimeofday(&et,NULL);
    int encryption_time = ((et.tv_sec - st.tv_sec) * 1000000) + (et.tv_usec - st.tv_usec);
    fill[0]=encryption_time;
    if(ret != 0){
        LOGD("Error encrypting");
        LOGD("%i",ret);
    }

    gettimeofday(&st,NULL);

    ret=mbedtls_gcm_auth_decrypt(&ctx,sizeof(encrypted),iv, sizeof(iv),NULL,0,tag, sizeof(tag),encrypted,decrypted);

    gettimeofday(&et,NULL);
    int decryption_time = ((et.tv_sec - st.tv_sec) * 1000000) + (et.tv_usec - st.tv_usec);
    fill[1]=decryption_time;

    if(ret != 0){
        LOGD("Error decrypting");
        LOGD("%i",ret);
    }

    LOGD("We are good");

    env->SetIntArrayRegion(result, 0, 3, fill);

    return result;

}

extern "C"
JNIEXPORT jintArray JNICALL
Java_com_example_juanperezdealgaba_sac_mbedTLS_ECDH(JNIEnv *env, jobject instance) {

    jintArray result;
    result = env->NewIntArray(3);
    jint fill[3];

    struct timeval st,et;

    int ret;
    mbedtls_ecdh_context ctx_cli, ctx_srv;
    mbedtls_entropy_context entropy;
    mbedtls_ctr_drbg_context ctr_drbg;
    unsigned char cli_to_srv[32], srv_to_cli[32];
    const char pers[] = "ecdh";

    mbedtls_ecdh_init( &ctx_cli );
    mbedtls_ecdh_init( &ctx_srv );
    mbedtls_ctr_drbg_init( &ctr_drbg );

    LOGD( "  . Seeding the random number generator..." );
    fflush( stdout );

    mbedtls_entropy_init( &entropy );
    if( ( ret = mbedtls_ctr_drbg_seed( &ctr_drbg, mbedtls_entropy_func, &entropy,
                                       (const unsigned char *) pers,
                                       sizeof pers ) ) != 0 )
    {
       LOGD( " failed\n  ! mbedtls_ctr_drbg_seed returned %d\n", ret );
        return 0;
    }

    LOGD( " ok\n" );

    /*
     * Client: inialize context and generate keypair
     */
    LOGD( "  . Setting up client context..." );
    fflush( stdout );

    ret = mbedtls_ecp_group_load( &ctx_cli.grp, MBEDTLS_ECP_DP_CURVE25519 );
    if( ret != 0 )
    {
        LOGD( " failed\n  ! mbedtls_ecp_group_load returned %d\n", ret );
        return 0;
    }

    ret = mbedtls_ecdh_gen_public( &ctx_cli.grp, &ctx_cli.d, &ctx_cli.Q,
                                   mbedtls_ctr_drbg_random, &ctr_drbg );
    if( ret != 0 )
    {
       LOGD( " failed\n  ! mbedtls_ecdh_gen_public returned %d\n", ret );
        return 0;
    }

    ret = mbedtls_mpi_write_binary( &ctx_cli.Q.X, cli_to_srv, 32 );
    if( ret != 0 )
    {
       LOGD( " failed\n  ! mbedtls_mpi_write_binary returned %d\n", ret );
        return 0;
    }

   LOGD( " ok\n" );

    /*
     * Server: initialize context and generate keypair
     */
   LOGD( "  . Setting up server context..." );
    fflush( stdout );

    ret = mbedtls_ecp_group_load( &ctx_srv.grp,  MBEDTLS_ECP_DP_SECP256R1  );
    if( ret != 0 )
    {
       LOGD( " failed\n  ! mbedtls_ecp_group_load returned %d\n", ret );
        return 0;
    }

    ret = mbedtls_ecdh_gen_public( &ctx_srv.grp, &ctx_srv.d, &ctx_srv.Q,
                                   mbedtls_ctr_drbg_random, &ctr_drbg );
    if( ret != 0 )
    {
       LOGD( " failed\n  ! mbedtls_ecdh_gen_public returned %d\n", ret );
        return 0;
    }

    ret = mbedtls_mpi_write_binary( &ctx_srv.Q.X, srv_to_cli, 32 );
    if( ret != 0 )
    {
       LOGD( " failed\n  ! mbedtls_mpi_write_binary returned %d\n", ret );
        return 0;
    }

   LOGD( " ok\n" );

    LOGD( "  . Server reading client key and computing secret..." );
    fflush( stdout );

    ret = mbedtls_mpi_lset( &ctx_srv.Qp.Z, 1 );
    if( ret != 0 )
    {
        LOGD( " failed\n  ! mbedtls_mpi_lset returned %d\n", ret );
        return 0;
    }

    ret = mbedtls_mpi_read_binary( &ctx_srv.Qp.X, cli_to_srv, 32 );
    if( ret != 0 )
    {
        LOGD( " failed\n  ! mbedtls_mpi_read_binary returned %d\n", ret );
        return 0;
    }

    gettimeofday(&st,NULL);
    ret = mbedtls_ecdh_compute_shared( &ctx_srv.grp, &ctx_srv.z,
                                       &ctx_srv.Qp, &ctx_srv.d,
                                       mbedtls_ctr_drbg_random, &ctr_drbg );
    gettimeofday(&et,NULL);
    int encryption_time = ((et.tv_sec - st.tv_sec) * 1000000) + (et.tv_usec - st.tv_usec);

    if( ret != 0 )
    {
        LOGD( " failed\n  ! mbedtls_ecdh_compute_shared returned %d\n", ret );
        return 0;
    }

    LOGD( " ok\n" );

    /*
     * Client: read peer's key and generate shared secret
     */
    LOGD( "  . Client reading server key and computing secret..." );
    fflush( stdout );

    ret = mbedtls_mpi_lset( &ctx_cli.Qp.Z, 1 );
    if( ret != 0 )
    {
        LOGD( " failed\n  ! mbedtls_mpi_lset returned %d\n", ret );
        return 0;
    }

    ret = mbedtls_mpi_read_binary( &ctx_cli.Qp.X, srv_to_cli, 32 );
    if( ret != 0 )
    {
        LOGD( " failed\n  ! mbedtls_mpi_read_binary returned %d\n", ret );
        return 0;
    }

    gettimeofday(&st,NULL);
    ret = mbedtls_ecdh_compute_shared( &ctx_cli.grp, &ctx_cli.z,
                                       &ctx_cli.Qp, &ctx_cli.d,
                                       mbedtls_ctr_drbg_random, &ctr_drbg );
    gettimeofday(&et,NULL);
    int decryption_time = ((et.tv_sec - st.tv_sec) * 1000000) + (et.tv_usec - st.tv_usec);
    fill[1]=encryption_time + decryption_time;
    if( ret != 0 )
    {
        LOGD( " failed\n  ! mbedtls_ecdh_compute_shared returned %d\n", ret );
        return 0;
    }

    LOGD( " ok\n" );

    /*
     * Verification: are the computed secrets equal?
     */
    LOGD( "  . Checking if both computed secrets are equal..." );
    fflush( stdout );

    ret = mbedtls_mpi_cmp_mpi( &ctx_cli.z, &ctx_srv.z );
    if( ret != 0 )
    {
        LOGD( " failed\n  ! mbedtls_ecdh_compute_shared returned %d\n", ret );
        return 0;
    }

    LOGD( " ok\n" );

    LOGD("We are good");

    env->SetIntArrayRegion(result, 0, 3, fill);

    return result;

}

extern "C"
JNIEXPORT jintArray JNICALL
Java_com_example_juanperezdealgaba_sac_mbedTLS_RSA(JNIEnv *env, jobject instance) {

    jintArray result;
    result = env->NewIntArray(3);
    jint fill[3];

    jintArray error;

    struct timeval st,et;

    unsigned char private_key[2048] = {
            0x30, 0x82, 0x04, 0xa2, 0x02, 0x01, 0x00, 0x02,
            0x82, 0x01, 0x01, 0x00, 0xc8, 0x40, 0x6f, 0xc7,
            0xd0, 0xc9, 0xfb, 0xd2, 0x5c, 0xf3, 0xc5, 0xbc,
            0x77, 0x0e, 0x68, 0x5a, 0x87, 0x4a, 0xb9, 0x57,
            0x08, 0xd4, 0x6b, 0x3e, 0x9a, 0x89, 0x8a, 0x9f,
            0xdd, 0xad, 0x16, 0xa8, 0xa3, 0x82, 0x42, 0x22,
            0x5b, 0x69, 0x77, 0x28, 0xba, 0x15, 0x2b, 0xb3,
            0xf3, 0x24, 0xea, 0xe4, 0x86, 0x34, 0x73, 0xc1,
            0xe5, 0x2b, 0x0b, 0xdb, 0xcd, 0x54, 0x35, 0x55,
            0xda, 0xf1, 0xfd, 0x61, 0x3f, 0x1e, 0xe7, 0x1e,
            0xf1, 0xc0, 0x38, 0xcb, 0xfc, 0x0d, 0x9d, 0x65,
            0xba, 0x50, 0x1f, 0xb7, 0x8d, 0xb3, 0x59, 0x8c,
            0x48, 0xf2, 0x34, 0xf1, 0x46, 0x86, 0xab, 0xf2,
            0xc0, 0xdd, 0x1c, 0x6d, 0xbe, 0xf9, 0x8f, 0x79,
            0xa8, 0x6f, 0x02, 0x25, 0x07, 0xba, 0xc0, 0x91,
            0x27, 0x46, 0xfb, 0xc8, 0xe8, 0x78, 0xc0, 0xb4,
            0x91, 0xb6, 0xd6, 0x5d, 0xbe, 0x74, 0x00, 0x60,
            0x73, 0xe9, 0x0e, 0x10, 0x60, 0x48, 0x82, 0xbf,
            0x50, 0x58, 0xc4, 0x6f, 0xf0, 0x4e, 0xcf, 0x92,
            0x43, 0x36, 0x75, 0xe5, 0x79, 0xb9, 0x78, 0x81,
            0xbc, 0xb6, 0xf5, 0x74, 0xfe, 0x0f, 0x3f, 0xd4,
            0x88, 0xfb, 0xe6, 0x4f, 0xd8, 0x8a, 0x60, 0xc9,
            0x25, 0xed, 0xa1, 0xef, 0x4a, 0x57, 0x81, 0xb1,
            0xce, 0xaf, 0x3d, 0xcf, 0x2a, 0x44, 0x51, 0x76,
            0x16, 0x54, 0x3d, 0x4b, 0x77, 0x09, 0x39, 0x6c,
            0x85, 0xc5, 0x0c, 0x59, 0x49, 0x12, 0xba, 0x3f,
            0x98, 0x1f, 0x29, 0x16, 0xc6, 0xed, 0x08, 0x09,
            0xa9, 0xdc, 0xe4, 0x92, 0x70, 0x71, 0x57, 0x1c,
            0xcb, 0xf2, 0xfa, 0x03, 0x84, 0xf0, 0xd8, 0x27,
            0xbc, 0xa5, 0x0a, 0x95, 0x21, 0xbc, 0x87, 0x61,
            0x9a, 0xfd, 0x78, 0xab, 0xe3, 0x2f, 0xef, 0x16,
            0x86, 0x5b, 0xe7, 0x8e, 0x48, 0xef, 0x3c, 0xa1,
            0x6e, 0xd6, 0xe7, 0xda, 0x4c, 0x69, 0x5c, 0x4f,
            0x7a, 0x20, 0x58, 0x1d, 0x02, 0x03, 0x01, 0x00,
            0x01, 0x02, 0x82, 0x01, 0x00, 0x78, 0xd8, 0xda,
            0x1c, 0x5d, 0xd5, 0xe7, 0x10, 0x96, 0x63, 0xce,
            0x8a, 0xe3, 0xd6, 0x60, 0x07, 0x71, 0xea, 0x18,
            0x5b, 0x7b, 0xca, 0xa5, 0x45, 0xcc, 0x81, 0x00,
            0x95, 0x65, 0x73, 0xd5, 0x5e, 0xc3, 0xfe, 0x11,
            0xe7, 0x25, 0xff, 0x49, 0x97, 0xdc, 0x64, 0x76,
            0x51, 0x4c, 0x84, 0x94, 0xf4, 0x80, 0x41, 0x1b,
            0x32, 0x82, 0x18, 0x2e, 0x39, 0xe1, 0x79, 0xd6,
            0x0e, 0x0f, 0xe9, 0x45, 0x9d, 0xf0, 0x37, 0xb8,
            0x06, 0xa6, 0xa1, 0xf8, 0x24, 0xb1, 0xe1, 0x8d,
            0x81, 0x1c, 0xa4, 0xc9, 0xdf, 0x3d, 0xb6, 0x64,
            0x6e, 0x12, 0x7f, 0x88, 0x8f, 0xaa, 0x9e, 0x0f,
            0x1a, 0x9a, 0x65, 0x55, 0x88, 0xad, 0x5d, 0x71,
            0xc6, 0x5b, 0x6d, 0x52, 0x80, 0x02, 0x60, 0x23,
            0x61, 0xf5, 0xb0, 0x12, 0xb6, 0xb6, 0x04, 0x59,
            0x57, 0x1f, 0x30, 0x95, 0xc1, 0x50, 0xf4, 0x34,
            0x5e, 0x00, 0xd5, 0x3e, 0x54, 0x76, 0x5e, 0xd4,
            0x26, 0xf8, 0xa7, 0x93, 0xf8, 0xe9, 0x67, 0xcc,
            0xf9, 0x04, 0x8e, 0xcb, 0x3f, 0x5e, 0xde, 0x89,
            0xc5, 0x9b, 0x80, 0x88, 0xfc, 0xef, 0xc1, 0x30,
            0xc4, 0x69, 0xb4, 0xde, 0xfc, 0x2c, 0x29, 0x18,
            0x89, 0x8e, 0xca, 0x93, 0xfd, 0x4a, 0x2c, 0x2e,
            0x75, 0x7f, 0x61, 0xd6, 0xcb, 0xd0, 0x8a, 0xfe,
            0x79, 0xf6, 0x47, 0x47, 0x9a, 0x6d, 0xb7, 0x27,
            0xf0, 0x75, 0x9e, 0x26, 0xd3, 0xd0, 0x3e, 0x54,
            0x3c, 0x19, 0x94, 0xa7, 0x9a, 0x79, 0xb8, 0x8e,
            0x6f, 0xa6, 0x2a, 0xba, 0x84, 0x89, 0x04, 0xc3,
            0x92, 0x16, 0xd1, 0x21, 0x5b, 0x0b, 0x59, 0x00,
            0xe7, 0x98, 0x63, 0x21, 0x85, 0x36, 0x88, 0x9b,
            0x7d, 0x8f, 0x9b, 0x41, 0x20, 0x52, 0x79, 0x2d,
            0x33, 0xb6, 0x85, 0xd1, 0xf4, 0x2e, 0x86, 0x88,
            0x60, 0xa7, 0xda, 0xa1, 0x2b, 0x2f, 0x82, 0xe1,
            0x3e, 0xba, 0x49, 0x31, 0xc9, 0x02, 0x81, 0x81,
            0x00, 0xe3, 0x51, 0xb6, 0x11, 0xb7, 0x61, 0x34,
            0x60, 0x73, 0xe1, 0xa0, 0x92, 0x25, 0x96, 0x36,
            0x79, 0x89, 0xbc, 0x22, 0x28, 0xcb, 0xcd, 0x2f,
            0x51, 0x15, 0xa4, 0x44, 0xb8, 0x2f, 0xf4, 0xea,
            0x07, 0x5f, 0xf0, 0x54, 0x7e, 0x72, 0x5f, 0xe9,
            0xe1, 0xec, 0xa2, 0xc9, 0x34, 0x12, 0x30, 0xa7,
            0xe1, 0xd0, 0x63, 0xbe, 0x64, 0xcc, 0x97, 0x98,
            0xdc, 0xff, 0xbe, 0xd7, 0x24, 0xab, 0x7c, 0x27,
            0x3d, 0x4f, 0x76, 0x46, 0x10, 0xb2, 0x29, 0xc5,
            0x6e, 0xbe, 0x27, 0x40, 0xf0, 0xfe, 0x33, 0xbe,
            0x84, 0x98, 0xe0, 0x5a, 0x6c, 0x17, 0xbf, 0xa1,
            0x1d, 0x07, 0x52, 0xb0, 0x28, 0x3c, 0xa6, 0x51,
            0x39, 0xc3, 0xb7, 0xb5, 0x6b, 0xcf, 0x8a, 0xa1,
            0x99, 0x94, 0x4d, 0xe1, 0x76, 0x17, 0x09, 0x18,
            0xe8, 0x5e, 0x5f, 0xfa, 0x76, 0x18, 0x70, 0x77,
            0x6c, 0x04, 0x9c, 0x80, 0x48, 0x37, 0x7c, 0xfa,
            0x17, 0x02, 0x81, 0x81, 0x00, 0xe1, 0x84, 0x75,
            0xd3, 0xbe, 0x3b, 0xe6, 0x11, 0x71, 0xe2, 0x56,
            0xd4, 0x31, 0xb8, 0x04, 0x66, 0xc2, 0x29, 0xa2,
            0x14, 0x16, 0x81, 0xa2, 0xd7, 0x47, 0x20, 0x9a,
            0xd6, 0x2a, 0x98, 0x8e, 0x01, 0x61, 0x12, 0x41,
            0xb6, 0xd7, 0x34, 0x7a, 0xc8, 0x07, 0x34, 0xe4,
            0x2f, 0x4c, 0xb9, 0xe3, 0x72, 0xa8, 0x16, 0xed,
            0x36, 0xfb, 0x18, 0xd7, 0x87, 0xa2, 0xff, 0x6a,
            0xfe, 0xde, 0x37, 0x5d, 0x1a, 0x45, 0xb1, 0x16,
            0x0a, 0x2c, 0x35, 0xab, 0x6e, 0xc1, 0x12, 0xac,
            0x7d, 0xe3, 0x7a, 0xd9, 0xc1, 0xda, 0xaa, 0x36,
            0xdc, 0xc8, 0x03, 0x30, 0x39, 0x59, 0xe6, 0x85,
            0x4e, 0x6b, 0xd2, 0x2d, 0xbf, 0xb8, 0xb4, 0x45,
            0xb1, 0x6b, 0xf4, 0xcf, 0x41, 0x4d, 0xab, 0x5c,
            0x29, 0x81, 0x4b, 0x87, 0x57, 0xf1, 0x0a, 0x6e,
            0x2d, 0x40, 0x80, 0x31, 0xc3, 0x1b, 0xdc, 0xc0,
            0x78, 0x3a, 0x1b, 0x83, 0xeb, 0x02, 0x81, 0x80,
            0x78, 0x37, 0x87, 0x65, 0x39, 0x28, 0xf4, 0x0d,
            0x2a, 0x5b, 0xa1, 0x92, 0x88, 0xc4, 0x37, 0x0c,
            0xf1, 0x95, 0x88, 0x2f, 0x31, 0x10, 0xd3, 0x3c,
            0x3b, 0x88, 0xc3, 0x3a, 0xf1, 0x49, 0xc1, 0xd6,
            0xa2, 0x9b, 0x33, 0xe4, 0x27, 0x52, 0xa8, 0x1a,
            0xee, 0x0d, 0x6d, 0x00, 0xd7, 0xb9, 0xd9, 0x9f,
            0x27, 0x99, 0x08, 0x60, 0xc0, 0x7e, 0x4f, 0xbe,
            0x58, 0x96, 0x31, 0xab, 0x57, 0xf1, 0x71, 0xc3,
            0x0f, 0xda, 0x09, 0xd5, 0xdc, 0x93, 0x10, 0xb1,
            0xaf, 0x68, 0x8d, 0x04, 0xa6, 0x3a, 0xf1, 0x3f,
            0xa8, 0xa5, 0xc5, 0xcc, 0x32, 0x87, 0x0a, 0x8a,
            0x92, 0x8b, 0xdd, 0x53, 0x7a, 0x37, 0xae, 0xef,
            0x30, 0x9d, 0x60, 0x19, 0xa3, 0x09, 0xba, 0xca,
            0xc0, 0xce, 0xab, 0x34, 0xcb, 0x9b, 0xe9, 0x0b,
            0x42, 0x95, 0xd9, 0x9c, 0x48, 0xf2, 0x79, 0x85,
            0xab, 0xae, 0xa4, 0x7d, 0x0c, 0xb3, 0x50, 0x83,
            0x02, 0x81, 0x80, 0x35, 0xc9, 0x91, 0x0c, 0xca,
            0xaf, 0xa0, 0xa5, 0x02, 0x83, 0x98, 0x70, 0x0d,
            0xd7, 0xb4, 0xfd, 0x09, 0x4c, 0x42, 0xc3, 0x05,
            0xc7, 0x2f, 0x9e, 0xa6, 0xf1, 0x48, 0xdc, 0xd1,
            0xd6, 0x06, 0xf0, 0x9f, 0x45, 0x6a, 0x75, 0x00,
            0x89, 0x1c, 0xcb, 0xbe, 0xa4, 0x47, 0xd4, 0x5c,
            0x39, 0x6d, 0xdd, 0x37, 0xe8, 0x17, 0xf5, 0xe8,
            0x17, 0xb9, 0xb8, 0x39, 0x11, 0x30, 0x64, 0xcf,
            0x7d, 0x66, 0xf0, 0x50, 0x34, 0xf7, 0x6b, 0xbf,
            0xb5, 0xa1, 0x48, 0xce, 0x35, 0xf4, 0xfc, 0x25,
            0x98, 0x74, 0x7d, 0x7e, 0xf8, 0xe0, 0x12, 0xf2,
            0x85, 0x88, 0x27, 0xf5, 0xa0, 0x3c, 0xa5, 0x42,
            0xa4, 0x23, 0x93, 0x39, 0xab, 0x8d, 0x7f, 0xce,
            0x9e, 0xda, 0x1b, 0xda, 0x39, 0x87, 0xc6, 0xc2,
            0x76, 0xd0, 0x36, 0x12, 0x60, 0x89, 0x7c, 0xb3,
            0x88, 0x9f, 0xd5, 0xc8, 0x3c, 0x73, 0x8f, 0x79,
            0x54, 0x7c, 0xb7, 0x02, 0x81, 0x80, 0x20, 0x31,
            0x41, 0x4c, 0xa4, 0xc9, 0x99, 0xd1, 0x0c, 0x83,
            0x2b, 0x94, 0x30, 0x1c, 0x25, 0x92, 0x84, 0x2c,
            0x16, 0x0e, 0xcf, 0x2b, 0x3b, 0x7b, 0x92, 0x2b,
            0x5d, 0xae, 0x46, 0x82, 0xf1, 0x7f, 0xc1, 0x42,
            0x1b, 0x96, 0x12, 0x01, 0x1d, 0x62, 0x29, 0xe5,
            0x8d, 0x4c, 0xa8, 0xf4, 0x47, 0x02, 0x9a, 0x92,
            0x65, 0x27, 0xbd, 0x49, 0x12, 0xd2, 0xc6, 0xcc,
            0xc7, 0x2b, 0x18, 0x02, 0x90, 0x4a, 0xd6, 0x65,
            0x6f, 0x2a, 0x3c, 0x40, 0x68, 0xf5, 0x36, 0x70,
            0xd4, 0x52, 0x82, 0xae, 0xa8, 0xa2, 0x38, 0xc0,
            0x00, 0x13, 0x5f, 0x15, 0x45, 0x1a, 0x95, 0x17,
            0xc1, 0x62, 0x9e, 0xc8, 0xe3, 0xe2, 0xc4, 0xf7,
            0xbf, 0xaa, 0xef, 0xfb, 0x15, 0xde, 0xa8, 0xa9,
            0x64, 0x3e, 0x0e, 0x5a, 0xa0, 0x12, 0x7d, 0x0d,
            0x5b, 0xb1, 0xef, 0xf3, 0xaf, 0xed, 0x8f, 0x5b,
            0xd8, 0xb3, 0xbc, 0xa1, 0x35, 0xd1
    };

    unsigned char public_key[] = {
            0x30, 0x82, 0x01, 0x22, 0x30, 0x0d, 0x06, 0x09,
            0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01,
            0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0f, 0x00,
            0x30, 0x82, 0x01, 0x0a, 0x02, 0x82, 0x01, 0x01,
            0x00, 0xc8, 0x40, 0x6f, 0xc7, 0xd0, 0xc9, 0xfb,
            0xd2, 0x5c, 0xf3, 0xc5, 0xbc, 0x77, 0x0e, 0x68,
            0x5a, 0x87, 0x4a, 0xb9, 0x57, 0x08, 0xd4, 0x6b,
            0x3e, 0x9a, 0x89, 0x8a, 0x9f, 0xdd, 0xad, 0x16,
            0xa8, 0xa3, 0x82, 0x42, 0x22, 0x5b, 0x69, 0x77,
            0x28, 0xba, 0x15, 0x2b, 0xb3, 0xf3, 0x24, 0xea,
            0xe4, 0x86, 0x34, 0x73, 0xc1, 0xe5, 0x2b, 0x0b,
            0xdb, 0xcd, 0x54, 0x35, 0x55, 0xda, 0xf1, 0xfd,
            0x61, 0x3f, 0x1e, 0xe7, 0x1e, 0xf1, 0xc0, 0x38,
            0xcb, 0xfc, 0x0d, 0x9d, 0x65, 0xba, 0x50, 0x1f,
            0xb7, 0x8d, 0xb3, 0x59, 0x8c, 0x48, 0xf2, 0x34,
            0xf1, 0x46, 0x86, 0xab, 0xf2, 0xc0, 0xdd, 0x1c,
            0x6d, 0xbe, 0xf9, 0x8f, 0x79, 0xa8, 0x6f, 0x02,
            0x25, 0x07, 0xba, 0xc0, 0x91, 0x27, 0x46, 0xfb,
            0xc8, 0xe8, 0x78, 0xc0, 0xb4, 0x91, 0xb6, 0xd6,
            0x5d, 0xbe, 0x74, 0x00, 0x60, 0x73, 0xe9, 0x0e,
            0x10, 0x60, 0x48, 0x82, 0xbf, 0x50, 0x58, 0xc4,
            0x6f, 0xf0, 0x4e, 0xcf, 0x92, 0x43, 0x36, 0x75,
            0xe5, 0x79, 0xb9, 0x78, 0x81, 0xbc, 0xb6, 0xf5,
            0x74, 0xfe, 0x0f, 0x3f, 0xd4, 0x88, 0xfb, 0xe6,
            0x4f, 0xd8, 0x8a, 0x60, 0xc9, 0x25, 0xed, 0xa1,
            0xef, 0x4a, 0x57, 0x81, 0xb1, 0xce, 0xaf, 0x3d,
            0xcf, 0x2a, 0x44, 0x51, 0x76, 0x16, 0x54, 0x3d,
            0x4b, 0x77, 0x09, 0x39, 0x6c, 0x85, 0xc5, 0x0c,
            0x59, 0x49, 0x12, 0xba, 0x3f, 0x98, 0x1f, 0x29,
            0x16, 0xc6, 0xed, 0x08, 0x09, 0xa9, 0xdc, 0xe4,
            0x92, 0x70, 0x71, 0x57, 0x1c, 0xcb, 0xf2, 0xfa,
            0x03, 0x84, 0xf0, 0xd8, 0x27, 0xbc, 0xa5, 0x0a,
            0x95, 0x21, 0xbc, 0x87, 0x61, 0x9a, 0xfd, 0x78,
            0xab, 0xe3, 0x2f, 0xef, 0x16, 0x86, 0x5b, 0xe7,
            0x8e, 0x48, 0xef, 0x3c, 0xa1, 0x6e, 0xd6, 0xe7,
            0xda, 0x4c, 0x69, 0x5c, 0x4f, 0x7a, 0x20, 0x58,
            0x1d, 0x02, 0x03, 0x01, 0x00, 0x01
    };

    unsigned char plaintext[]= {0x8d, 0x4c, 0xa8, 0xf4, 0x47, 0x02, 0x9a, 0x92,
                       0x65, 0x27, 0xbd, 0x49, 0x12, 0xd2, 0xc6, 0xcc,
                       0xc7, 0x2b, 0x18, 0x02, 0x90, 0x4a, 0xd6, 0x65,
                       0x6f, 0x2a, 0x3c, 0x40, 0x68, 0xf5, 0x36, 0x70,
                       0xd4, 0x52, 0x82, 0xae, 0xa8, 0xa2, 0x38, 0xc0,
                       0x00, 0x13, 0x5f, 0x15, 0x45, 0x1a, 0x95, 0x17,
                       0xc1, 0x62, 0x9e, 0xc8, 0xe3, 0xe2, 0xc4, 0xf7,
                       0xbf, 0xaa, 0xef, 0xfb, 0x15, 0xde, 0xa8, 0xa9,
                       0x64, 0x3e, 0x0e, 0x5a, 0xa0, 0x12, 0x7d, 0x0d,
                       0x5b, 0xb1, 0xef, 0xf3, 0xaf, 0xed, 0x8f, 0x5b,
                       0xd8, 0xb3, 0xbc, 0xa1, 0x35, 0xd1};
    int ret = 0;
    mbedtls_pk_context pk;
    mbedtls_pk_context privk;
    unsigned char buf[MBEDTLS_MPI_MAX_SIZE];
    size_t olen = 0;
    mbedtls_ctr_drbg_context ctr_drbg;
    mbedtls_ctr_drbg_context ctr_drbg2;
    mbedtls_entropy_context entropy;
    const char *pers = "rsa_genkey";


    mbedtls_pk_init( &pk );
    mbedtls_pk_init( &privk );

    size_t olen_dec = 0;
    unsigned char output_decrypted[MBEDTLS_MPI_MAX_SIZE];

    ret = mbedtls_pk_parse_public_key( &pk, public_key, sizeof(public_key));

    /*
     * Read the RSA public key
     */
    if( ret != 0 )
    {
        printf( " failed\n  ! mbedtls_pk_parsing public key, -ret" );
        return error;
    }

    mbedtls_ctr_drbg_init( &ctr_drbg );

    mbedtls_entropy_init( &entropy );
    if( ( ret = mbedtls_ctr_drbg_seed( &ctr_drbg, mbedtls_entropy_func, &entropy,
                                       (const unsigned char *) pers,
                                       strlen( pers ) ) ) != 0 )
    {
        LOGD( " failed\n  ! mbedtls_ctr_drbg_seed returned %d\n", ret );
        return 0;
    }

    mbedtls_ctr_drbg_init( &ctr_drbg2 );

    mbedtls_entropy_init( &entropy );
    if( ( ret = mbedtls_ctr_drbg_seed( &ctr_drbg2, mbedtls_entropy_func, &entropy,
                                       (const unsigned char *) pers,
                                       strlen( pers ) ) ) != 0 )
    {
        LOGD( " failed\n  ! mbedtls_ctr_drbg_seed returned %d\n", ret );
        return 0;
    }

    gettimeofday(&st,NULL);
    ret = mbedtls_pk_encrypt( &pk, plaintext, sizeof(plaintext),
                              buf, &olen, sizeof(buf),
                              mbedtls_ctr_drbg_random, &ctr_drbg );
    gettimeofday(&et,NULL);
    int encryption_time = ((et.tv_sec - st.tv_sec) * 1000000) + (et.tv_usec - st.tv_usec);
    fill[0]=encryption_time;

    if( ret != 0 )
    {
        printf( " failed\n  ! mbedtls_pk_encrypt returned -0x%04x\n", -ret );
        return error;
    }

    mbedtls_pk_free(&pk);


    ret = mbedtls_pk_parse_key( &privk, private_key,2048,NULL,NULL);

    if( ret != 0 )
    {
        printf( " failed\n  ! mbedtls_pk_parsing private key, -ret" );
        return error;
    }

    gettimeofday(&st,NULL);
    ret =mbedtls_pk_decrypt( &privk, buf, olen, output_decrypted, &olen_dec, sizeof(output_decrypted),
                             mbedtls_ctr_drbg_random, &ctr_drbg2 );
    gettimeofday(&et,NULL);
    if(ret !=0){
        LOGD(" failed\n  ! mbedtls_pk_decrypt returned -0x%04x\n", -ret);
    }

    int decryption_time = ((et.tv_sec - st.tv_sec) * 1000000) + (et.tv_usec - st.tv_usec);
    fill[1]=decryption_time;

    LOGD( " ok\n" );

    LOGD("We are good");

    env->SetIntArrayRegion(result, 0, 3, fill);

    return result;

}
